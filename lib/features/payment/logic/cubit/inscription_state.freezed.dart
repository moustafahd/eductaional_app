// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'inscription_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

/// @nodoc
mixin _$InscriptionState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() inscriptionInitial,
    required TResult Function() inscriptionLoading,
    required TResult Function(InscriptionResponse data) inscriptionSuccess,
    required TResult Function(String error) inscriptionFailure,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? inscriptionInitial,
    TResult? Function()? inscriptionLoading,
    TResult? Function(InscriptionResponse data)? inscriptionSuccess,
    TResult? Function(String error)? inscriptionFailure,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? inscriptionInitial,
    TResult Function()? inscriptionLoading,
    TResult Function(InscriptionResponse data)? inscriptionSuccess,
    TResult Function(String error)? inscriptionFailure,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InscriptionInitial value) inscriptionInitial,
    required TResult Function(InscriptionLoading value) inscriptionLoading,
    required TResult Function(InscriptionSuccess value) inscriptionSuccess,
    required TResult Function(InscriptionFailure value) inscriptionFailure,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InscriptionInitial value)? inscriptionInitial,
    TResult? Function(InscriptionLoading value)? inscriptionLoading,
    TResult? Function(InscriptionSuccess value)? inscriptionSuccess,
    TResult? Function(InscriptionFailure value)? inscriptionFailure,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InscriptionInitial value)? inscriptionInitial,
    TResult Function(InscriptionLoading value)? inscriptionLoading,
    TResult Function(InscriptionSuccess value)? inscriptionSuccess,
    TResult Function(InscriptionFailure value)? inscriptionFailure,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InscriptionStateCopyWith<$Res> {
  factory $InscriptionStateCopyWith(
    InscriptionState value,
    $Res Function(InscriptionState) then,
  ) = _$InscriptionStateCopyWithImpl<$Res, InscriptionState>;
}

/// @nodoc
class _$InscriptionStateCopyWithImpl<$Res, $Val extends InscriptionState>
    implements $InscriptionStateCopyWith<$Res> {
  _$InscriptionStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of InscriptionState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$InscriptionInitialImplCopyWith<$Res> {
  factory _$$InscriptionInitialImplCopyWith(
    _$InscriptionInitialImpl value,
    $Res Function(_$InscriptionInitialImpl) then,
  ) = __$$InscriptionInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InscriptionInitialImplCopyWithImpl<$Res>
    extends _$InscriptionStateCopyWithImpl<$Res, _$InscriptionInitialImpl>
    implements _$$InscriptionInitialImplCopyWith<$Res> {
  __$$InscriptionInitialImplCopyWithImpl(
    _$InscriptionInitialImpl _value,
    $Res Function(_$InscriptionInitialImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of InscriptionState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$InscriptionInitialImpl implements _InscriptionInitial {
  const _$InscriptionInitialImpl();

  @override
  String toString() {
    return 'InscriptionState.inscriptionInitial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InscriptionInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() inscriptionInitial,
    required TResult Function() inscriptionLoading,
    required TResult Function(InscriptionResponse data) inscriptionSuccess,
    required TResult Function(String error) inscriptionFailure,
  }) {
    return inscriptionInitial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? inscriptionInitial,
    TResult? Function()? inscriptionLoading,
    TResult? Function(InscriptionResponse data)? inscriptionSuccess,
    TResult? Function(String error)? inscriptionFailure,
  }) {
    return inscriptionInitial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? inscriptionInitial,
    TResult Function()? inscriptionLoading,
    TResult Function(InscriptionResponse data)? inscriptionSuccess,
    TResult Function(String error)? inscriptionFailure,
    required TResult orElse(),
  }) {
    if (inscriptionInitial != null) {
      return inscriptionInitial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InscriptionInitial value) inscriptionInitial,
    required TResult Function(InscriptionLoading value) inscriptionLoading,
    required TResult Function(InscriptionSuccess value) inscriptionSuccess,
    required TResult Function(InscriptionFailure value) inscriptionFailure,
  }) {
    return inscriptionInitial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InscriptionInitial value)? inscriptionInitial,
    TResult? Function(InscriptionLoading value)? inscriptionLoading,
    TResult? Function(InscriptionSuccess value)? inscriptionSuccess,
    TResult? Function(InscriptionFailure value)? inscriptionFailure,
  }) {
    return inscriptionInitial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InscriptionInitial value)? inscriptionInitial,
    TResult Function(InscriptionLoading value)? inscriptionLoading,
    TResult Function(InscriptionSuccess value)? inscriptionSuccess,
    TResult Function(InscriptionFailure value)? inscriptionFailure,
    required TResult orElse(),
  }) {
    if (inscriptionInitial != null) {
      return inscriptionInitial(this);
    }
    return orElse();
  }
}

abstract class _InscriptionInitial implements InscriptionState {
  const factory _InscriptionInitial() = _$InscriptionInitialImpl;
}

/// @nodoc
abstract class _$$InscriptionLoadingImplCopyWith<$Res> {
  factory _$$InscriptionLoadingImplCopyWith(
    _$InscriptionLoadingImpl value,
    $Res Function(_$InscriptionLoadingImpl) then,
  ) = __$$InscriptionLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InscriptionLoadingImplCopyWithImpl<$Res>
    extends _$InscriptionStateCopyWithImpl<$Res, _$InscriptionLoadingImpl>
    implements _$$InscriptionLoadingImplCopyWith<$Res> {
  __$$InscriptionLoadingImplCopyWithImpl(
    _$InscriptionLoadingImpl _value,
    $Res Function(_$InscriptionLoadingImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of InscriptionState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$InscriptionLoadingImpl implements InscriptionLoading {
  const _$InscriptionLoadingImpl();

  @override
  String toString() {
    return 'InscriptionState.inscriptionLoading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InscriptionLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() inscriptionInitial,
    required TResult Function() inscriptionLoading,
    required TResult Function(InscriptionResponse data) inscriptionSuccess,
    required TResult Function(String error) inscriptionFailure,
  }) {
    return inscriptionLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? inscriptionInitial,
    TResult? Function()? inscriptionLoading,
    TResult? Function(InscriptionResponse data)? inscriptionSuccess,
    TResult? Function(String error)? inscriptionFailure,
  }) {
    return inscriptionLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? inscriptionInitial,
    TResult Function()? inscriptionLoading,
    TResult Function(InscriptionResponse data)? inscriptionSuccess,
    TResult Function(String error)? inscriptionFailure,
    required TResult orElse(),
  }) {
    if (inscriptionLoading != null) {
      return inscriptionLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InscriptionInitial value) inscriptionInitial,
    required TResult Function(InscriptionLoading value) inscriptionLoading,
    required TResult Function(InscriptionSuccess value) inscriptionSuccess,
    required TResult Function(InscriptionFailure value) inscriptionFailure,
  }) {
    return inscriptionLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InscriptionInitial value)? inscriptionInitial,
    TResult? Function(InscriptionLoading value)? inscriptionLoading,
    TResult? Function(InscriptionSuccess value)? inscriptionSuccess,
    TResult? Function(InscriptionFailure value)? inscriptionFailure,
  }) {
    return inscriptionLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InscriptionInitial value)? inscriptionInitial,
    TResult Function(InscriptionLoading value)? inscriptionLoading,
    TResult Function(InscriptionSuccess value)? inscriptionSuccess,
    TResult Function(InscriptionFailure value)? inscriptionFailure,
    required TResult orElse(),
  }) {
    if (inscriptionLoading != null) {
      return inscriptionLoading(this);
    }
    return orElse();
  }
}

abstract class InscriptionLoading implements InscriptionState {
  const factory InscriptionLoading() = _$InscriptionLoadingImpl;
}

/// @nodoc
abstract class _$$InscriptionSuccessImplCopyWith<$Res> {
  factory _$$InscriptionSuccessImplCopyWith(
    _$InscriptionSuccessImpl value,
    $Res Function(_$InscriptionSuccessImpl) then,
  ) = __$$InscriptionSuccessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({InscriptionResponse data});
}

/// @nodoc
class __$$InscriptionSuccessImplCopyWithImpl<$Res>
    extends _$InscriptionStateCopyWithImpl<$Res, _$InscriptionSuccessImpl>
    implements _$$InscriptionSuccessImplCopyWith<$Res> {
  __$$InscriptionSuccessImplCopyWithImpl(
    _$InscriptionSuccessImpl _value,
    $Res Function(_$InscriptionSuccessImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of InscriptionState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? data = null}) {
    return _then(
      _$InscriptionSuccessImpl(
        null == data
            ? _value.data
            : data // ignore: cast_nullable_to_non_nullable
                as InscriptionResponse,
      ),
    );
  }
}

/// @nodoc

class _$InscriptionSuccessImpl implements InscriptionSuccess {
  const _$InscriptionSuccessImpl(this.data);

  @override
  final InscriptionResponse data;

  @override
  String toString() {
    return 'InscriptionState.inscriptionSuccess(data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InscriptionSuccessImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  /// Create a copy of InscriptionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$InscriptionSuccessImplCopyWith<_$InscriptionSuccessImpl> get copyWith =>
      __$$InscriptionSuccessImplCopyWithImpl<_$InscriptionSuccessImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() inscriptionInitial,
    required TResult Function() inscriptionLoading,
    required TResult Function(InscriptionResponse data) inscriptionSuccess,
    required TResult Function(String error) inscriptionFailure,
  }) {
    return inscriptionSuccess(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? inscriptionInitial,
    TResult? Function()? inscriptionLoading,
    TResult? Function(InscriptionResponse data)? inscriptionSuccess,
    TResult? Function(String error)? inscriptionFailure,
  }) {
    return inscriptionSuccess?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? inscriptionInitial,
    TResult Function()? inscriptionLoading,
    TResult Function(InscriptionResponse data)? inscriptionSuccess,
    TResult Function(String error)? inscriptionFailure,
    required TResult orElse(),
  }) {
    if (inscriptionSuccess != null) {
      return inscriptionSuccess(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InscriptionInitial value) inscriptionInitial,
    required TResult Function(InscriptionLoading value) inscriptionLoading,
    required TResult Function(InscriptionSuccess value) inscriptionSuccess,
    required TResult Function(InscriptionFailure value) inscriptionFailure,
  }) {
    return inscriptionSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InscriptionInitial value)? inscriptionInitial,
    TResult? Function(InscriptionLoading value)? inscriptionLoading,
    TResult? Function(InscriptionSuccess value)? inscriptionSuccess,
    TResult? Function(InscriptionFailure value)? inscriptionFailure,
  }) {
    return inscriptionSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InscriptionInitial value)? inscriptionInitial,
    TResult Function(InscriptionLoading value)? inscriptionLoading,
    TResult Function(InscriptionSuccess value)? inscriptionSuccess,
    TResult Function(InscriptionFailure value)? inscriptionFailure,
    required TResult orElse(),
  }) {
    if (inscriptionSuccess != null) {
      return inscriptionSuccess(this);
    }
    return orElse();
  }
}

abstract class InscriptionSuccess implements InscriptionState {
  const factory InscriptionSuccess(final InscriptionResponse data) =
      _$InscriptionSuccessImpl;

  InscriptionResponse get data;

  /// Create a copy of InscriptionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$InscriptionSuccessImplCopyWith<_$InscriptionSuccessImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InscriptionFailureImplCopyWith<$Res> {
  factory _$$InscriptionFailureImplCopyWith(
    _$InscriptionFailureImpl value,
    $Res Function(_$InscriptionFailureImpl) then,
  ) = __$$InscriptionFailureImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String error});
}

/// @nodoc
class __$$InscriptionFailureImplCopyWithImpl<$Res>
    extends _$InscriptionStateCopyWithImpl<$Res, _$InscriptionFailureImpl>
    implements _$$InscriptionFailureImplCopyWith<$Res> {
  __$$InscriptionFailureImplCopyWithImpl(
    _$InscriptionFailureImpl _value,
    $Res Function(_$InscriptionFailureImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of InscriptionState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? error = null}) {
    return _then(
      _$InscriptionFailureImpl(
        error:
            null == error
                ? _value.error
                : error // ignore: cast_nullable_to_non_nullable
                    as String,
      ),
    );
  }
}

/// @nodoc

class _$InscriptionFailureImpl implements InscriptionFailure {
  const _$InscriptionFailureImpl({required this.error});

  @override
  final String error;

  @override
  String toString() {
    return 'InscriptionState.inscriptionFailure(error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InscriptionFailureImpl &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  /// Create a copy of InscriptionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$InscriptionFailureImplCopyWith<_$InscriptionFailureImpl> get copyWith =>
      __$$InscriptionFailureImplCopyWithImpl<_$InscriptionFailureImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() inscriptionInitial,
    required TResult Function() inscriptionLoading,
    required TResult Function(InscriptionResponse data) inscriptionSuccess,
    required TResult Function(String error) inscriptionFailure,
  }) {
    return inscriptionFailure(error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? inscriptionInitial,
    TResult? Function()? inscriptionLoading,
    TResult? Function(InscriptionResponse data)? inscriptionSuccess,
    TResult? Function(String error)? inscriptionFailure,
  }) {
    return inscriptionFailure?.call(error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? inscriptionInitial,
    TResult Function()? inscriptionLoading,
    TResult Function(InscriptionResponse data)? inscriptionSuccess,
    TResult Function(String error)? inscriptionFailure,
    required TResult orElse(),
  }) {
    if (inscriptionFailure != null) {
      return inscriptionFailure(error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InscriptionInitial value) inscriptionInitial,
    required TResult Function(InscriptionLoading value) inscriptionLoading,
    required TResult Function(InscriptionSuccess value) inscriptionSuccess,
    required TResult Function(InscriptionFailure value) inscriptionFailure,
  }) {
    return inscriptionFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InscriptionInitial value)? inscriptionInitial,
    TResult? Function(InscriptionLoading value)? inscriptionLoading,
    TResult? Function(InscriptionSuccess value)? inscriptionSuccess,
    TResult? Function(InscriptionFailure value)? inscriptionFailure,
  }) {
    return inscriptionFailure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InscriptionInitial value)? inscriptionInitial,
    TResult Function(InscriptionLoading value)? inscriptionLoading,
    TResult Function(InscriptionSuccess value)? inscriptionSuccess,
    TResult Function(InscriptionFailure value)? inscriptionFailure,
    required TResult orElse(),
  }) {
    if (inscriptionFailure != null) {
      return inscriptionFailure(this);
    }
    return orElse();
  }
}

abstract class InscriptionFailure implements InscriptionState {
  const factory InscriptionFailure({required final String error}) =
      _$InscriptionFailureImpl;

  String get error;

  /// Create a copy of InscriptionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$InscriptionFailureImplCopyWith<_$InscriptionFailureImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
